---
timestamp: 2025-12-11T17:12
feature: Improved Authentication Flow
type: plan
status: ready
scope: browser-only (mobile deferred to separate feature)
estimate: 4-6 hours
---

# Improved Authentication Flow - Implementation Plan

## Executive Summary

This plan implements **Option B: Unified Auth Check (Browser-Simplified)** from the research document. We will fix the root cause of the "Not logged in" bug by making `ProtectedRoute` aware of session validity, while keeping the scope browser-only and deferring true offline-first capabilities to a future React Native mobile app.

**Key Changes:**

1. New `useAuthCheck` hook - unified session validation (checks localStorage + session validity)
2. Updated `ProtectedRoute` - uses hook, shows loading state, redirects on invalid session
3. Clear localStorage on session expiry - prevents stale keys from allowing unauthorized access
4. Simplify/remove `SessionExpiredModal` - redirect to /auth instead of showing modal over protected content

## Problem Statement

**Current Bug**: Users see protected pages (like `/songs`) with "Not logged in" status in the sidebar.

**Root Cause**:

- `ProtectedRoute` checks only localStorage keys (`currentUserId`, `currentBandId`)
- Page components rely on `AuthContext` state that hasn't loaded yet
- localStorage keys persist even after session expires
- Result: Route protection passes, but user is not actually authenticated

**Timeline of the Bug:**

```
T=0ms    User navigates to /songs
T=1ms    ProtectedRoute reads localStorage → finds stale keys → ALLOWS ACCESS ✅
T=2ms    Page renders with empty AuthContext (currentUser = null)
T=3ms    Sidebar displays "Not logged in" (fallback for null currentUser)
T=50ms   AuthContext loads session from Supabase → Session expired
T=151ms  AuthContext sets sessionExpired = true
T=200ms  Page still visible with "Not logged in" ❌
```

## Architecture Overview

### Current Flow (Broken)

```
User Request
    ↓
ProtectedRoute (checks localStorage ONLY)
    ↓
Allow access (localStorage keys exist)
    ↓
Page renders with AuthContext
    ↓
AuthContext detects expired session (too late!)
    ↓
Shows "Not logged in" but page still visible ❌
```

### New Flow (Fixed)

```
User Request
    ↓
ProtectedRoute
    ↓
useAuthCheck hook
    ├─ Check localStorage keys
    ├─ Check session validity (SessionManager.isSessionValid)
    ├─ Check expiry time (grace period for brief offline)
    └─ If invalid: clear localStorage, return unauthorized
    ↓
[Loading state while checking]
    ↓
If unauthorized → Redirect to /auth ✅
If authorized → Render protected content ✅
```

### Session Expiry Flow (Simplified)

```
Session Expires (detected by AuthContext)
    ↓
Clear localStorage keys immediately
    ↓
Redirect to /auth (no modal)
    ↓
Show toast: "Session expired. Please log in again."
```

## Component Architecture

### 1. useAuthCheck Hook (NEW)

**File**: `src/hooks/useAuthCheck.ts`

**Purpose**: Single source of truth for "is user authenticated?"

**Logic**:

```typescript
function useAuthCheck(): { isAuthenticated: boolean | null, isChecking: boolean }

1. Check localStorage keys (currentUserId, currentBandId)
   - If missing → return { isAuthenticated: false, isChecking: false }

2. Load session from SessionManager.loadSession()
   - If no session → clear localStorage → return unauthorized

3. Check session validity with SessionManager.isSessionValid()
   - If invalid → clear localStorage → return unauthorized

4. Grace period for brief offline (browser-only):
   - If session expires within 1-2 hours → allow access
   - If session expired > 2 hours ago → require re-auth

5. Return { isAuthenticated: true, isChecking: false }
```

**States**:

- `isAuthenticated: null` - Checking in progress
- `isAuthenticated: true` - Valid session
- `isAuthenticated: false` - Invalid/expired session

### 2. ProtectedRoute Component (MODIFIED)

**File**: `src/components/ProtectedRoute.tsx`

**Changes**:

```typescript
// BEFORE: Direct localStorage check
const currentUserId = localStorage.getItem('currentUserId')
const currentBandId = localStorage.getItem('currentBandId')
setIsAuthorized(!!(currentUserId && currentBandId))

// AFTER: Use useAuthCheck hook
const { isAuthenticated, isChecking } = useAuthCheck()

// Show loading spinner while checking
if (isChecking) return <div>Loading...</div>

// Redirect to /auth if not authenticated
if (!isAuthenticated) {
  return <Navigate to="/auth" replace />
}
```

**Loading State**:

- Show spinner/skeleton while `isChecking === true`
- Prevents flash of content
- Better UX than `return null`

### 3. AuthContext (MODIFIED)

**File**: `src/contexts/AuthContext.tsx`

**Changes to Session Expiry Handling**:

```typescript
// In checkSession function (line 110-122)
const checkSession = () => {
  const currentSession = SessionManager.loadSession()
  if (!currentSession || !SessionManager.isSessionValid(currentSession)) {
    console.warn('⚠️ Session expired - redirecting to login')

    // NEW: Clear localStorage keys
    localStorage.removeItem('currentUserId')
    localStorage.removeItem('currentBandId')

    // NEW: Clear session state
    setSession(null)
    setUser(null)
    setSessionExpired(false) // Don't show modal, redirect instead

    // NEW: Redirect to /auth
    navigate('/auth?reason=session-expired')

    // Clear interval
    if (sessionCheckIntervalRef.current) {
      clearInterval(sessionCheckIntervalRef.current)
      sessionCheckIntervalRef.current = null
    }
  }
}
```

**Note**: We'll need to pass `navigate` function to AuthContext or use a different approach to trigger redirect. One option is to set a flag and let the SessionExpiredModal component handle the redirect.

### 4. SessionExpiredModal (SIMPLIFIED)

**File**: `src/components/auth/SessionExpiredModal.tsx`

**Option A: Remove Entirely**

- Delete the component
- Session expiry → immediate redirect to /auth
- Show toast notification instead

**Option B: Keep for Edge Cases** (Recommended)

- Only show modal if session expires on `/auth` page itself
- For all other pages → redirect handled by ProtectedRoute

**Implementation (Option B)**:

```typescript
export const SessionExpiredModal: React.FC = () => {
  const { sessionExpired } = useAuth()
  const navigate = useNavigate()
  const location = useLocation()

  useEffect(() => {
    if (sessionExpired) {
      // If already on /auth page, show modal
      if (location.pathname === '/auth') {
        // Show modal (current behavior)
        return
      }

      // For all other pages, redirect
      navigate('/auth?reason=session-expired')
      showToast('Session expired. Please log in again.', 'info')
    }
  }, [sessionExpired, location, navigate])

  // Only render modal if on /auth page
  if (!sessionExpired || location.pathname !== '/auth') {
    return null
  }

  return (
    // ... existing modal JSX ...
  )
}
```

## File Structure

### Files to Create

```
src/
  hooks/
    useAuthCheck.ts         # NEW - Unified auth check hook
```

### Files to Modify

```
src/
  components/
    ProtectedRoute.tsx      # Use useAuthCheck hook
    auth/
      SessionExpiredModal.tsx # Simplify (redirect instead of modal)
  contexts/
    AuthContext.tsx         # Clear localStorage on expiry
```

### Files to Test

```
tests/
  unit/
    hooks/
      useAuthCheck.test.ts  # NEW - Unit tests for hook
  e2e/
    auth/
      session-expiry.spec.ts # NEW - E2E tests for session expiry
      protected-routes.spec.ts # NEW - E2E tests for route protection
```

## Grace Period Implementation (Browser-Simplified)

**Requirement**: Allow brief offline access (1-2 hours) for users who lose connectivity during a gig.

**Implementation**:

```typescript
// In useAuthCheck hook
const session = SessionManager.loadSession()
if (!session) {
  clearLocalStorage()
  return { isAuthenticated: false, isChecking: false }
}

// Check if session is expired
if (!SessionManager.isSessionValid(session)) {
  // Calculate how long ago session expired
  const expiresAt = session.expiresAt || 0
  const hoursExpired = (Date.now() - expiresAt) / (1000 * 60 * 60)

  // Grace period: 1-2 hours
  const GRACE_PERIOD_HOURS = 1.5

  if (hoursExpired < GRACE_PERIOD_HOURS) {
    // Within grace period - allow access
    console.log(
      `⏰ Session expired ${Math.round(hoursExpired * 60)} minutes ago - within grace period`
    )
    return { isAuthenticated: true, isChecking: false }
  }

  // Grace period expired - require re-auth
  console.warn(
    `⛔ Session expired ${Math.round(hoursExpired)} hours ago - re-authentication required`
  )
  clearLocalStorage()
  return { isAuthenticated: false, isChecking: false }
}

// Session is valid
return { isAuthenticated: true, isChecking: false }
```

**Why 1.5 hours?**

- Typical gig/practice session: 1-3 hours
- Supabase default session: 1 hour
- Grace period: 0.5-1 hour after expiry
- Total: 1.5-2 hours offline access

## Testing Strategy

### Unit Tests

**Test File**: `tests/unit/hooks/useAuthCheck.test.ts`

```typescript
describe('useAuthCheck', () => {
  test('returns unauthorized when no localStorage keys', () => {
    // Clear localStorage
    // Call hook
    // Assert isAuthenticated = false
  })

  test('returns unauthorized when session is null', () => {
    // Set localStorage keys
    // Mock SessionManager.loadSession() to return null
    // Assert clears localStorage
    // Assert isAuthenticated = false
  })

  test('returns authorized when session is valid', () => {
    // Set localStorage keys
    // Mock valid session
    // Assert isAuthenticated = true
  })

  test('returns unauthorized when session expired > grace period', () => {
    // Set localStorage keys
    // Mock expired session (3 hours ago)
    // Assert clears localStorage
    // Assert isAuthenticated = false
  })

  test('returns authorized when session expired within grace period', () => {
    // Set localStorage keys
    // Mock expired session (30 minutes ago)
    // Assert isAuthenticated = true
  })

  test('clears localStorage on invalid session', () => {
    // Set localStorage keys
    // Mock invalid session
    // Assert localStorage.removeItem called for currentUserId
    // Assert localStorage.removeItem called for currentBandId
  })
})
```

### E2E Tests

**Test File**: `tests/e2e/auth/session-expiry.spec.ts`

```typescript
test.describe('Session Expiry', () => {
  test('redirects to /auth when session expires on protected page', async ({
    page,
  }) => {
    // Login user
    // Navigate to /songs
    // Expire session (clear Supabase token in localStorage)
    // Trigger auth check (navigation or page reload)
    // Assert redirected to /auth
    // Assert NOT showing protected content
  })

  test('shows toast notification on session expiry', async ({ page }) => {
    // Login user
    // Navigate to /songs
    // Expire session
    // Trigger auth check
    // Assert toast visible: "Session expired. Please log in again."
  })

  test('does not show SessionExpiredModal on protected pages', async ({
    page,
  }) => {
    // Login user
    // Navigate to /songs
    // Expire session
    // Trigger auth check
    // Assert modal NOT visible
    // Assert redirected to /auth
  })
})
```

**Test File**: `tests/e2e/auth/protected-routes.spec.ts`

```typescript
test.describe('Protected Routes', () => {
  test('redirects to /auth when accessing /songs without session', async ({
    page,
  }) => {
    // Clear all localStorage
    // Navigate to /songs
    // Assert redirected to /auth
  })

  test('redirects to /auth when accessing /songs with expired session', async ({
    page,
  }) => {
    // Set localStorage keys (currentUserId, currentBandId)
    // Set expired session in localStorage (rock_on_session)
    // Navigate to /songs
    // Assert redirected to /auth
  })

  test('shows loading state before checking auth', async ({ page }) => {
    // Set valid session
    // Navigate to /songs
    // Assert loading spinner visible briefly
    // Assert /songs page renders after loading
  })

  test('redirects to /auth?view=get-started when user has no band', async ({
    page,
  }) => {
    // Set currentUserId in localStorage
    // Do NOT set currentBandId
    // Navigate to /songs
    // Assert redirected to /auth?view=get-started
  })
})
```

## Edge Cases Handled

| Scenario                                    | Expected Behavior                           | Implementation                                                         |
| ------------------------------------------- | ------------------------------------------- | ---------------------------------------------------------------------- |
| Direct URL to `/songs` with expired session | Redirect to `/auth` before showing content  | `useAuthCheck` detects expired session, ProtectedRoute redirects       |
| Session expires while user is active        | Redirect to `/auth` with toast notification | AuthContext `checkSession` clears localStorage, redirect               |
| User goes offline with valid session        | Allow access for 1.5 hours (grace period)   | `useAuthCheck` checks expiry time, allows access within grace period   |
| User goes offline with expired session      | Require re-authentication (no access)       | `useAuthCheck` detects expired session, clears localStorage            |
| Multi-tab logout                            | All tabs redirect to `/auth`                | Existing storage event listener (line 140-173) already handles this ✅ |
| User returns after 3+ hours offline         | Require re-authentication                   | `useAuthCheck` detects grace period expired                            |

## Security Considerations

### 1. localStorage Keys Are Not Auth State

- **Problem**: localStorage keys persist indefinitely, don't indicate session validity
- **Solution**: `useAuthCheck` always validates against `SessionManager.isSessionValid()`
- **Result**: localStorage keys are just hints, not source of truth

### 2. Grace Period Risk

- **Risk**: Allowing expired session access could expose data
- **Mitigation**:
  - Grace period is short (1.5 hours)
  - User can only access their own cached IndexedDB data
  - No server requests succeed with expired token
  - Clear boundary: > 1.5 hours = must re-auth

### 3. Clear Separation: Browser vs Mobile

- **Browser**: Strict session validation, short grace period
- **Mobile** (future): Offline-first, secure token storage, biometric auth
- **Why**: Browser localStorage is vulnerable, mobile has Keychain/Keystore

## Migration Path (Mobile Offline-First)

When we build the React Native mobile app, the architecture will be:

```
Mobile App (Future)
├── Secure token storage (Keychain/Keystore)
├── 30-day offline access window
├── Biometric re-authentication
├── Background session refresh
└── True offline-first architecture

Browser App (This Implementation)
├── localStorage (best-effort)
├── 1.5-hour grace period (brief offline)
├── Strict session validation
└── Redirect on expired session
```

**Key Insight**: By implementing strict browser validation now, we set a clear precedent. Mobile will have better security primitives and can justify longer offline access.

## Implementation Phases

### Phase 1: Setup (30 min)

- Create `src/hooks/` directory if doesn't exist
- Create `useAuthCheck.ts` skeleton
- Add helper functions (clearLocalStorage, getGraceRemaining)

### Phase 2: Tests (1-2 hours)

- Write unit tests for `useAuthCheck` hook
- Write E2E tests for protected routes
- Write E2E tests for session expiry
- Follow TDD: tests first, then implementation

### Phase 3: Core Implementation (1.5-2 hours)

- Implement `useAuthCheck` hook
- Update `ProtectedRoute` to use hook
- Add loading state component
- Clear localStorage on session expiry in AuthContext

### Phase 4: Integration (1 hour)

- Simplify/update `SessionExpiredModal`
- Add toast notifications for session expiry
- Handle redirect to `/auth?reason=session-expired`
- Add query param to show "Session expired" message on login page

### Phase 5: Polish & Validation (1 hour)

- Run all tests (unit + E2E)
- Manual testing of all edge cases
- Update documentation
- Code review checklist

## Success Criteria

### Must Have

- ✅ No "Not logged in" status on protected pages with valid session
- ✅ Immediate redirect to `/auth` on expired session
- ✅ localStorage cleared when session becomes invalid
- ✅ Loading state shown during auth check
- ✅ Grace period (1.5 hours) for brief offline access
- ✅ All E2E tests pass
- ✅ All unit tests pass

### Nice to Have

- ✅ Toast notification on session expiry
- ✅ Loading spinner matches design system
- ✅ Session expiry reason shown on login page
- ✅ Analytics tracking for session expiry events

## Rollout Plan

### Development

1. Implement on feature branch: `feature/improved-auth-flow`
2. Run full test suite locally
3. Manual testing of all scenarios
4. Code review

### Staging

1. Deploy to staging environment
2. Smoke test critical flows
3. Check analytics for any new errors

### Production

1. Deploy during low-traffic window
2. Monitor error rates for 24 hours
3. Watch for session expiry patterns
4. Be ready to rollback if issues arise

## Risks & Mitigations

| Risk                                | Impact | Probability | Mitigation                                          |
| ----------------------------------- | ------ | ----------- | --------------------------------------------------- |
| Breaking existing auth flow         | HIGH   | LOW         | Comprehensive E2E tests, manual testing             |
| Grace period too strict             | MEDIUM | MEDIUM      | Make configurable (1-2 hours), gather user feedback |
| Performance impact of auth check    | LOW    | LOW         | Hook is lightweight, minimal overhead               |
| Users lose unsaved work on redirect | MEDIUM | LOW         | Future: implement auto-save before redirect         |

## Follow-Up Work (Future Features)

### Short-Term (Next Sprint)

- Add session refresh on user activity (extend session automatically)
- Implement auto-save before session expiry redirect
- Add analytics tracking for session expiry patterns

### Medium-Term (Next Quarter)

- Increase Supabase session duration from 1 hour to 24 hours
- Implement "Remember me" checkbox (extends session to 30 days)
- Add session activity indicator (last sync time, etc.)

### Long-Term (Next Year)

- React Native mobile app with true offline-first architecture
- Secure token storage (Keychain/Keystore)
- Biometric re-authentication
- Background session refresh

## References

- Research Document: `.claude/features/improved-auth-flow/2025-12-11T15:15_research.md`
- Current Implementation: `src/components/ProtectedRoute.tsx`
- Session Management: `src/services/auth/SessionManager.ts`
- Auth Context: `src/contexts/AuthContext.tsx`
- E2E Test Example: `tests/e2e/auth/login-smoke.spec.ts`

---

**Plan Status**: Ready for Implementation
**Estimate**: 4-6 hours
**Dependencies**: None (can start immediately)
**Approval**: Pending user confirmation
