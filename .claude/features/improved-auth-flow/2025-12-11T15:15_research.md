---
timestamp: 2025-12-11T15:15
appended: 2025-12-11T16:54
feature: Improved Authentication Flow
type: research
status: complete
scope: browser-only (mobile deferred to separate feature)
---

# Improved Authentication Flow - Research Document

## Executive Summary

Users are seeing protected pages (like /songs) with "Not logged in" status in the sidebar, which indicates a critical race condition in the authentication flow. The issue stems from **ProtectedRoute checking only localStorage keys** while **the page components rely on AuthContext state** that hasn't loaded yet.

**Critical Finding**: There is a fundamental disconnect between:

- **ProtectedRoute** (guards routes) - checks `localStorage.getItem('currentUserId')`
- **Page Components** (display UI) - use `currentUser` from AuthContext
- **Result**: Route protection passes immediately, but AuthContext takes time to populate state

## Strategic Decision: Browser-Strict, Mobile-Offline

**Decision**: Implement strict session validation for the browser version. Defer true offline-first capabilities to a future React Native mobile app.

**Rationale**:

| Aspect               | Browser (Web)                  | React Native (Mobile)               |
| -------------------- | ------------------------------ | ----------------------------------- |
| Storage Persistence  | Best-effort (can be cleared)   | Guaranteed (SQLite/Realm)           |
| Secure Token Storage | localStorage (vulnerable)      | Keychain/Keystore (secure)          |
| Background Refresh   | Not possible                   | Supported                           |
| Biometric Auth       | Limited                        | Full support (Face ID, fingerprint) |
| User Expectation     | "Log in to use"                | "Just works"                        |
| Offline Duration     | Short grace period (1-2 hours) | Indefinite (30 days)                |

**Implications for This Feature**:

- Focus on fixing the session validation bug in browser
- Remove/simplify offline session complexity
- Require valid session for all protected routes
- On session expiry → redirect to login (no modal over content)
- Mobile offline-first architecture tracked separately in `react-native-app` feature

---

## 1. Current State Analysis

### 1.1 Authentication Architecture Overview

The authentication system consists of four main layers:

```
User Request → ProtectedRoute → React Router → Page Component (with AuthContext)
                    ↓                               ↓
              localStorage only               Supabase + IndexedDB
              (instant check)                 (async operations)
```

**Key Components:**

1. **ProtectedRoute** (`src/components/ProtectedRoute.tsx`)
   - Guards all protected routes (/songs, /setlists, /shows, etc.)
   - Checks ONLY localStorage keys: `currentUserId` and `currentBandId`
   - Runs synchronously with a single useEffect
   - Redirects to /auth if keys are missing

2. **AuthContext** (`src/contexts/AuthContext.tsx`)
   - Manages complete auth state (user, session, bands)
   - Performs async operations (Supabase auth, IndexedDB queries, initial sync)
   - Populates `currentUser`, `currentBand`, and `session` state
   - Monitors session expiry every 30 seconds

3. **SessionManager** (`src/services/auth/SessionManager.ts`)
   - Stores/loads sessions from localStorage
   - Manages offline session (30-day validity)
   - Session keys:
     - `rock_on_session` - Full session with expiresAt timestamp
     - `rock_on_offline_session` - Offline fallback (userId, userName, userEmail, savedAt)

4. **SupabaseAuthService** (`src/services/auth/SupabaseAuthService.ts`)
   - Integrates with Supabase authentication
   - Syncs user data from Supabase to IndexedDB
   - Handles sign in/out, session refresh
   - Triggers `onAuthStateChange` callbacks

### 1.2 Current Flow: User Returns to App

When a user navigates to a protected route (e.g., `/songs`):

**Step 1: ProtectedRoute Check (INSTANT)**

```typescript
// ProtectedRoute.tsx line 22-31
useEffect(() => {
  const checkAuth = () => {
    const currentUserId = localStorage.getItem('currentUserId')
    const currentBandId = localStorage.getItem('currentBandId')

    setIsAuthorized(!!(currentUserId && currentBandId))
    setIsChecking(false)
  }
  checkAuth()
}, [])
```

- ✅ If both keys exist → Allow access immediately
- ❌ If either missing → Redirect to /auth

**Step 2: AuthContext Initialization (ASYNC - takes time)**

```typescript
// AuthContext.tsx line 175-275
useEffect(() => {
  const loadInitialSession = async () => {
    setLoading(true)

    // 1. Get session from Supabase (async)
    const currentSession = await authService.getSession()

    // 2. Check if session is expired
    if (currentSession) {
      setSession(currentSession)
      setUser(currentSession.user)
    }

    // 3. Load from localStorage
    const storedUserId = localStorage.getItem('currentUserId')
    const storedBandId = localStorage.getItem('currentBandId')

    // 4. Set current user on sync engine
    repository.setCurrentUser(storedUserId)

    // 5. Check if initial sync needed
    const needsSync = await repository.isInitialSyncNeeded()
    if (needsSync) {
      await repository.performInitialSync(storedUserId)
    }

    // 6. Load user data from IndexedDB
    await loadUserData(storedUserId, storedBandId)

    // 7. Start realtime sync
    // ... realtime setup ...

    setLoading(false)
  }

  loadInitialSession()
}, [])
```

**Step 3: Page Component Renders**

```typescript
// SongsPage.tsx line 1128-1129
<ModernLayout
  bandName={currentBand?.name || 'No Band Selected'}
  userEmail={currentUser?.email || 'Not logged in'}
>
```

### 1.3 The Race Condition

**Timeline of Events:**

```
T=0ms    User navigates to /songs
T=1ms    ProtectedRoute reads localStorage → finds userId + bandId → ALLOWS ACCESS
T=2ms    Page component renders with empty AuthContext (currentUser = null)
T=3ms    Sidebar displays "Not logged in" (fallback for null currentUser)
T=50ms   AuthContext loads session from Supabase
T=150ms  Session expires at check fails (expiresAt < Date.now())
T=151ms  AuthContext sets sessionExpired = true, session = null
T=200ms  Page still visible with "Not logged in" status
```

**The Problem:**

1. ProtectedRoute allows access based on stale localStorage keys
2. localStorage keys persist even after session expires
3. AuthContext detects expired session but doesn't trigger redirect
4. User sees protected content with "Not logged in" (screenshot scenario)

### 1.4 Session Expiry Detection

**Current Implementation:**

```typescript
// AuthContext.tsx line 98-137
useEffect(() => {
  if (!session) {
    setSessionExpired(false)
    return
  }

  const checkSession = () => {
    const currentSession = SessionManager.loadSession()
    if (!currentSession || !SessionManager.isSessionValid(currentSession)) {
      console.warn('⚠️ Session expired - user needs to re-authenticate')
      setSessionExpired(true)
      setSession(null)
      setUser(null)
      // Clear interval since session is expired
    }
  }

  checkSession() // Check immediately
  sessionCheckIntervalRef.current = setInterval(checkSession, 30000) // Then every 30s
}, [session])
```

**Issues:**

- ✅ Detects session expiry correctly
- ✅ Sets `sessionExpired` flag
- ✅ Shows SessionExpiredModal
- ❌ **Does NOT clear localStorage keys** (`currentUserId`, `currentBandId`)
- ❌ **Does NOT redirect user away from protected content**
- ❌ User can still navigate between protected pages with expired session

### 1.5 localStorage Keys Used

**Auth-Related Keys:**

1. `currentUserId` - Set by AuthContext, checked by ProtectedRoute
2. `currentBandId` - Set by AuthContext, checked by ProtectedRoute
3. `rock_on_session` - Full session object (managed by SessionManager)
4. `rock_on_offline_session` - Offline fallback (managed by SessionManager)
5. `sb-{project-ref}-auth-token` - Supabase auth token (managed by Supabase SDK)

**Key Lifecycle:**

- **Set on login**: All keys set when user signs in
- **Cleared on logout**: Explicitly cleared by `logout()` function
- **Session expiry**: Only `rock_on_session` and `sb-*` keys are relevant, but `currentUserId` and `currentBandId` are NOT cleared

### 1.6 Offline Session Behavior

**Current Implementation:**

```typescript
// SessionManager.ts line 46-91
static saveOfflineSession(session: AuthSession): void {
  const offlineSession = {
    userId: session.user.id,
    userName: session.user.name,
    userEmail: session.user.email,
    savedAt: Date.now(),
  }
  localStorage.setItem(OFFLINE_SESSION_KEY, JSON.stringify(offlineSession))
}

static loadOfflineSession() {
  // Offline sessions are valid for 30 days
  const thirtyDaysInMs = 30 * 24 * 60 * 60 * 1000
  if (Date.now() - offlineSession.savedAt > thirtyDaysInMs) {
    localStorage.removeItem(OFFLINE_SESSION_KEY)
    return null
  }
  return offlineSession
}
```

**Intent**: Allow users to work offline for up to 30 days
**Reality**: Offline session is saved but NEVER USED by ProtectedRoute or AuthContext

---

## 2. Gap Analysis: Why Screenshot Issue Occurs

### 2.1 Root Cause

**The screenshot shows `/songs` page with "Not logged in" because:**

1. User previously logged in → localStorage keys were set (`currentUserId`, `currentBandId`)
2. User closed browser/tab → Session token expired in Supabase
3. User returns to app → Browser navigates to `/songs` (or redirects from `/`)
4. ProtectedRoute checks localStorage → Finds stale keys → **Allows access** ✅
5. Page renders with AuthContext → `currentUser` is null (not loaded yet) → Shows "Not logged in"
6. AuthContext initializes → Loads session from Supabase → Session is expired
7. AuthContext sets `sessionExpired = true` → Shows SessionExpiredModal
8. **User sees protected content with expired session** ❌

### 2.2 Why Current Implementation Fails

**Design Flaw: Split Responsibility**

- **ProtectedRoute**: "Are you allowed to see this page?" (checks localStorage)
- **AuthContext**: "Who are you?" (checks Supabase session validity)
- **Problem**: ProtectedRoute has no awareness of session validity

**localStorage Keys Are Not Auth State**

- localStorage keys are just strings
- They persist indefinitely (until explicitly cleared)
- They don't indicate whether Supabase session is valid
- ProtectedRoute treats them as source of truth

**Session Expiry Handling Is Incomplete**

- Session expiry is detected ✅
- SessionExpiredModal is shown ✅
- But user stays on protected page ❌
- localStorage keys are not cleared ❌

### 2.3 Additional Edge Cases Discovered

**Edge Case 1: Multi-Tab Logout**

- User logs out in Tab A → `logout()` clears localStorage
- Tab B detects change via `storage` event listener → Also logs out ✅
- **Works correctly** (see AuthContext.tsx line 140-173)

**Edge Case 2: Multi-Tab Login**

- User logs in Tab A → localStorage keys are set
- Tab B detects change → Reloads page (see line 151-155)
- **Works, but could be improved** (full page reload is heavy)

**Edge Case 3: Session Refresh During Active Use**

- User is actively using app
- Session expires while on page
- Session expiry check runs every 30s
- SessionExpiredModal appears ✅
- **Works as intended for active users**

**Edge Case 4: User Returns After 1+ Hour Offline**

- User logs in → Closes laptop (goes offline)
- 1+ hours later → Opens laptop (still offline)
- Navigates to app → ProtectedRoute allows access (localStorage keys exist)
- Page shows content but "Not logged in" (no session)
- Goes back online → AuthContext detects expired session
- **Same issue as screenshot scenario**

**Edge Case 5: Direct Navigation to Protected Route**

- User bookmarks `/songs` or types URL directly
- Has expired session (localStorage keys exist from previous login)
- ProtectedRoute allows access → Shows "Not logged in"
- **This is the exact screenshot scenario**

**Edge Case 6: User Has Valid Online Session but Goes Offline**

- User is logged in with valid session
- Goes offline (airplane mode, no WiFi)
- Should be able to work offline with cached data
- **Current implementation unclear on this behavior**

---

## 3. Offline Requirements Analysis

### 3.1 PWA Offline Patterns

**Common Offline Authentication Patterns:**

1. **Token-Based Offline (JWT)**
   - Store JWT token locally
   - Validate token expiry locally (without server)
   - Allow offline access if token not expired
   - Refresh token when back online

2. **Offline Session Window**
   - Allow offline access for X hours after last online validation
   - After X hours, require re-authentication
   - Clear offline window on explicit logout

3. **Offline Grace Period**
   - If user goes offline with valid session → Allow access
   - If user returns after expiry → Require re-auth before allowing access
   - Grace period = last known session expiry time

4. **Optimistic Offline (Current Approach)**
   - Store user ID + band ID locally
   - Allow offline access if keys exist
   - Sync when back online
   - **Issue**: No expiry enforcement

### 3.2 What Data Is Needed for Offline Access?

**User Needs to Access Offline:**

- ✅ Songs (read/create/edit) - Stored in IndexedDB
- ✅ Setlists (read/create/edit) - Stored in IndexedDB
- ✅ Shows (read/create/edit) - Stored in IndexedDB
- ✅ Practices (read/create/edit) - Stored in IndexedDB
- ✅ Band members (read-only) - Stored in IndexedDB
- ❌ Band settings (requires admin role validation from server)
- ❌ Invite new members (requires server to send invites)

**Required for Offline Access:**

- `userId` - To filter data by user
- `bandId` - To filter data by current band
- `userRole` - To enforce permissions (admin vs member)
- User's bands list - To allow band switching

**Currently Stored Offline:**

- IndexedDB: All user data (songs, setlists, shows, practices, bands, memberships)
- localStorage: `currentUserId`, `currentBandId`, `rock_on_offline_session`

### 3.3 How Long Should Offline Sessions Be Valid?

**Current Implementation:**

- Offline session: 30 days (SessionManager.ts line 76)
- Online session: 1 hour (Supabase default, can be configured)

**Industry Standards:**

- Google Drive: 30 days offline
- Microsoft Office: 30 days offline
- Notion: 7 days offline
- Spotify: Indefinite (until explicit logout)

**Recommended Approach:**

- **Offline session**: 30 days (current) ✅
- **Online session**: 24 hours (extend Supabase default from 1 hour)
- **Active session extension**: Extend session on user activity (every API call)

### 3.4 Offline Scenarios & Expected Behavior

**Scenario 1: User Goes Offline with Valid Session**

```
User is logged in (session valid) → Goes offline → Works offline
Expected: Continue working offline until offline session expires (30 days)
Current: Unclear - depends on when ProtectedRoute is checked
```

**Scenario 2: User Goes Offline with Expired Session**

```
User session expires (e.g., 1 hour) → User goes offline → Tries to access app
Expected: Require re-authentication (can't work offline with expired session)
Current: Allows access if localStorage keys exist (WRONG)
```

**Scenario 3: User Returns Online After Offline Period**

```
User worked offline for 2 days → Goes back online → Has offline session
Expected: Sync changes, refresh online session, continue working
Current: Initial sync runs, but session expiry handling unclear
```

**Scenario 4: User Returns Online After Session Expired While Offline**

```
User worked offline → Session expired while offline → Goes back online
Expected: Show SessionExpiredModal, require re-auth, then sync changes
Current: SessionExpiredModal shows, but user sees content first (WRONG)
```

### 3.5 PWA Best Practices

**1. Clear Offline Boundaries**

- Show offline indicator (✅ Already implemented - Sidebar connection status)
- Disable features that require online access (⚠️ Not fully implemented)
- Queue actions for when online (✅ Partially implemented - sync engine)

**2. Offline Session Management**

- Store session expiry time locally
- Validate expiry locally before allowing access
- Require re-auth when coming back online with expired session

**3. Data Sync Strategy**

- Sync on app launch (when online)
- Sync on user activity (when online)
- Show sync status clearly (✅ Already implemented)

**4. Security Considerations**

- Don't store sensitive data unencrypted (passwords, tokens)
- Clear offline data on explicit logout
- Implement offline session expiry (30 days max)

---

## 4. All Edge Cases Documented

### 4.1 Navigation Edge Cases

| #   | Scenario                                           | Current Behavior                | Expected Behavior                   | Risk     |
| --- | -------------------------------------------------- | ------------------------------- | ----------------------------------- | -------- |
| 1   | Direct URL to /songs (expired session)             | Shows page with "Not logged in" | Redirect to /auth immediately       | **HIGH** |
| 2   | Navigate from / to /songs (expired session)        | Shows page with "Not logged in" | Redirect to /auth immediately       | **HIGH** |
| 3   | Refresh page on /songs (expired session)           | Shows page with "Not logged in" | Redirect to /auth immediately       | **HIGH** |
| 4   | Navigate between protected pages (expired session) | Allows navigation               | Redirect to /auth on any navigation | **HIGH** |

### 4.2 Session Lifecycle Edge Cases

| #   | Scenario                                      | Current Behavior             | Expected Behavior               | Risk     |
| --- | --------------------------------------------- | ---------------------------- | ------------------------------- | -------- |
| 5   | User returns after 1 hour (session expired)   | Shows content, then modal    | Redirect before showing content | **HIGH** |
| 6   | Session expires while user is active          | Shows SessionExpiredModal ✅ | Same (correct)                  | **LOW**  |
| 7   | User closes/reopens browser (session valid)   | Logs in successfully ✅      | Same (correct)                  | **LOW**  |
| 8   | User closes/reopens browser (session expired) | Shows content, then modal    | Redirect before showing content | **HIGH** |

### 4.3 Offline Edge Cases

| #   | Scenario                                   | Current Behavior                          | Expected Behavior                             | Risk       |
| --- | ------------------------------------------ | ----------------------------------------- | --------------------------------------------- | ---------- |
| 9   | User goes offline (valid session)          | Unclear - may show "Not logged in"        | Continue working offline                      | **MEDIUM** |
| 10  | User goes offline (expired session)        | Shows content (localStorage keys exist)   | Require re-authentication                     | **HIGH**   |
| 11  | User works offline for 5 days              | Likely works, but unclear                 | Allow until offline session expires (30 days) | **MEDIUM** |
| 12  | User returns online after 30+ days offline | Offline session expired, unclear behavior | Require re-authentication                     | **MEDIUM** |

### 4.4 Multi-Tab Edge Cases

| #   | Scenario                 | Current Behavior                  | Expected Behavior            | Risk       |
| --- | ------------------------ | --------------------------------- | ---------------------------- | ---------- |
| 13  | User logs out in Tab A   | Tab B logs out ✅ (storage event) | Same (correct)               | **LOW**    |
| 14  | User logs in Tab A       | Tab B reloads page ✅             | Same (correct, but heavy)    | **LOW**    |
| 15  | Session expires in Tab A | Tab B not notified                | Tab B should also show modal | **MEDIUM** |

### 4.5 Data Integrity Edge Cases

| #   | Scenario                                                   | Current Behavior                               | Expected Behavior                            | Risk       |
| --- | ---------------------------------------------------------- | ---------------------------------------------- | -------------------------------------------- | ---------- |
| 16  | User makes changes offline → Session expires → Goes online | Changes sync, unclear if session checked first | Check session, re-auth if expired, then sync | **MEDIUM** |
| 17  | User makes changes → Session expires mid-sync              | Unclear - may fail silently                    | Queue changes, re-auth, then retry sync      | **HIGH**   |

---

## 5. Risk Analysis

### 5.1 High Risk Issues

**Risk H1: Unauthorized Access to Protected Content**

- **Impact**: User sees protected data without valid authentication
- **Probability**: High (happens every time user returns with expired session)
- **Evidence**: Screenshot showing /songs with "Not logged in"
- **Security Concern**: ⚠️ MEDIUM - User can only see their own cached data, but session expiry is not enforced

**Risk H2: Data Loss During Expired Session**

- **Impact**: User makes changes with expired session → Changes may not sync
- **Probability**: Medium (if user ignores SessionExpiredModal)
- **Data Loss**: Potential data loss if offline changes can't sync later

**Risk H3: Stale localStorage Keys**

- **Impact**: localStorage keys persist indefinitely, allowing access with expired session
- **Probability**: High (current implementation)
- **Confusion**: User thinks they're logged in when they're not

### 5.2 Medium Risk Issues

**Risk M1: Inconsistent Offline Behavior**

- **Impact**: Unclear when offline access is allowed vs denied
- **Probability**: High (not clearly defined)
- **User Experience**: Confusing and unpredictable

**Risk M2: Multi-Tab Session Sync**

- **Impact**: Session expiry in one tab doesn't notify other tabs
- **Probability**: Medium (only affects multi-tab users)
- **User Experience**: Inconsistent state across tabs

**Risk M3: Heavy Page Reload on Multi-Tab Login**

- **Impact**: Full page reload in other tabs when user logs in
- **Probability**: Low (uncommon use case)
- **User Experience**: Jarring, could lose unsaved changes

### 5.3 Low Risk Issues

**Risk L1: Session Refresh Not Implemented**

- **Impact**: User must re-login every 1 hour (Supabase default)
- **Probability**: High (current implementation)
- **User Experience**: Annoying for active users

**Risk L2: Offline Session Not Used**

- **Impact**: Offline session is saved but never checked by ProtectedRoute
- **Probability**: High (current implementation)
- **Wasted Effort**: Offline session logic exists but isn't used

---

## 6. Open Questions for User

### 6.1 Product Requirements

**Q1: Offline Access Scope**

- Should users be able to work offline indefinitely until explicit logout?
- Or should offline access have a time limit (30 days, 7 days)?
- Should offline access require a valid session when going offline?

**Q2: Session Expiry User Experience**

- When session expires, should we:
  - A) Immediately redirect to login (lose current page state)
  - B) Show modal overlay (keep page visible but block interaction)
  - C) Allow continued offline access (with sync disabled)

**Q3: Mobile Use Case Priority**

- Is offline access a PRIMARY use case (musicians on stage with no WiFi)?
- Or is it a SECONDARY use case (convenience, not critical)?
- This affects how aggressively we enforce session expiry

### 6.2 Technical Decisions

**Q4: Session Duration**

- Supabase default: 1 hour
- Should we extend to 24 hours? 7 days?
- Should session refresh automatically on user activity?

**Q5: localStorage Keys as Auth Source**

- Should ProtectedRoute continue using localStorage keys?
- Or should it use AuthContext session state (requires refactor)?
- Or hybrid approach (check both, prefer session state)?

**Q6: Offline Session Implementation**

- Should we actually USE the offline session feature?
- Or remove it if not needed?
- Or improve it to be the primary offline auth mechanism?

### 6.3 Security & Compliance

**Q7: Sensitive Data Storage**

- Are there any compliance requirements (GDPR, CCPA)?
- Should we encrypt IndexedDB data?
- Should we clear all data on logout (vs keeping for multi-user scenarios)?

**Q8: Session Security**

- Should we implement device fingerprinting?
- Should we detect suspicious activity (e.g., session from different location)?
- Should we enforce re-authentication for sensitive actions (e.g., inviting members)?

---

## 7. Recommended Approaches

### 7.1 Option A: Fix localStorage Sync (Quick Fix)

**Description**: Keep current architecture, fix the synchronization issue

**Changes:**

1. When session expires, clear localStorage keys (`currentUserId`, `currentBandId`)
2. Listen for session state changes in ProtectedRoute
3. Redirect immediately when session becomes invalid

**Pros:**

- ✅ Minimal code changes
- ✅ Fast to implement (1-2 hours)
- ✅ Fixes immediate security issue

**Cons:**

- ❌ Still relies on localStorage as source of truth
- ❌ Doesn't address offline access properly
- ❌ Band-aid solution, not architectural fix

**Implementation:**

```typescript
// AuthContext.tsx
const checkSession = () => {
  const currentSession = SessionManager.loadSession()
  if (!currentSession || !SessionManager.isSessionValid(currentSession)) {
    setSessionExpired(true)
    setSession(null)
    setUser(null)

    // NEW: Clear localStorage keys
    localStorage.removeItem('currentUserId')
    localStorage.removeItem('currentBandId')
  }
}

// ProtectedRoute.tsx
useEffect(() => {
  // NEW: Listen for storage events
  const handleStorageChange = (e: StorageEvent) => {
    if (e.key === 'currentUserId' || e.key === 'currentBandId') {
      if (
        !localStorage.getItem('currentUserId') ||
        !localStorage.getItem('currentBandId')
      ) {
        // Redirect to login
        navigate('/auth')
      }
    }
  }
  window.addEventListener('storage', handleStorageChange)
  return () => window.removeEventListener('storage', handleStorageChange)
}, [])
```

**Estimated Effort**: 2-4 hours
**Risk**: Low (minimal changes)

---

### 7.2 Option B: Unified Auth Check (Recommended)

**Description**: Make ProtectedRoute aware of session validity

**Changes:**

1. Create a new `useAuthCheck()` hook that checks BOTH localStorage AND session validity
2. ProtectedRoute uses this hook instead of direct localStorage access
3. Implement proper offline session logic

**Pros:**

- ✅ Fixes root cause (split responsibility)
- ✅ Proper offline support
- ✅ Cleaner architecture
- ✅ Single source of truth for "is user authenticated?"

**Cons:**

- ⚠️ Medium complexity (4-8 hours)
- ⚠️ Requires testing edge cases thoroughly
- ⚠️ May impact performance (async checks)

**Implementation:**

```typescript
// New file: hooks/useAuthCheck.ts
export function useAuthCheck() {
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null)

  useEffect(() => {
    const checkAuth = async () => {
      // 1. Check localStorage keys
      const userId = localStorage.getItem('currentUserId')
      const bandId = localStorage.getItem('currentBandId')

      if (!userId || !bandId) {
        setIsAuthenticated(false)
        return
      }

      // 2. Check if online
      if (navigator.onLine) {
        // 3. Online: Check Supabase session validity
        const session = SessionManager.loadSession()
        if (!session || !SessionManager.isSessionValid(session)) {
          // Session expired, clear localStorage
          localStorage.removeItem('currentUserId')
          localStorage.removeItem('currentBandId')
          setIsAuthenticated(false)
          return
        }
        setIsAuthenticated(true)
      } else {
        // 4. Offline: Check offline session validity
        const offlineSession = SessionManager.loadOfflineSession()
        if (!offlineSession) {
          // Offline session expired (30 days)
          localStorage.removeItem('currentUserId')
          localStorage.removeItem('currentBandId')
          setIsAuthenticated(false)
          return
        }
        setIsAuthenticated(true)
      }
    }

    checkAuth()
  }, [])

  return { isAuthenticated, isChecking: isAuthenticated === null }
}

// ProtectedRoute.tsx
export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isChecking } = useAuthCheck()

  if (isChecking) return null

  if (!isAuthenticated) {
    return <Navigate to="/auth" replace />
  }

  return <>{children}</>
}
```

**Estimated Effort**: 4-8 hours
**Risk**: Medium (requires thorough testing)

---

### 7.3 Option C: Full Offline-First Refactor (Comprehensive)

**Description**: Complete offline-first authentication system

**Changes:**

1. Implement offline session as primary auth mechanism
2. Sync Supabase session in background (when online)
3. Always allow offline access within 30-day window
4. Auto-refresh session on user activity

**Pros:**

- ✅ Best offline UX
- ✅ Matches PWA best practices
- ✅ Future-proof architecture
- ✅ Clear separation: local auth vs remote sync

**Cons:**

- ❌ High complexity (16-24 hours)
- ❌ Significant refactor required
- ❌ May need Supabase config changes (session duration)
- ❌ Risk of regression bugs

**Implementation Outline:**

1. Create `OfflineAuthManager` class
2. Store offline session with expiry (30 days from last online session refresh)
3. ProtectedRoute checks offline session, not Supabase session
4. Background job: Refresh Supabase session when online + user active
5. When offline session expires, clear all data and redirect to login
6. On logout, clear both online and offline sessions

**Estimated Effort**: 16-24 hours
**Risk**: High (major refactor)

---

### 7.4 Option D: Redirect on Expired Session (Simplest)

**Description**: When session expires, immediately redirect to login (don't show modal)

**Changes:**

1. Remove SessionExpiredModal
2. When session expires, clear localStorage and navigate to /auth
3. Show toast message: "Your session expired. Please log in again."

**Pros:**

- ✅ Simplest to implement (1 hour)
- ✅ No ambiguity (you're either in or out)
- ✅ Fixes screenshot issue immediately

**Cons:**

- ❌ Loses current page state (annoying for users)
- ❌ No offline support
- ❌ Doesn't leverage offline session feature

**Implementation:**

```typescript
// AuthContext.tsx
const checkSession = () => {
  const currentSession = SessionManager.loadSession()
  if (!currentSession || !SessionManager.isSessionValid(currentSession)) {
    // Clear all auth state
    logout()

    // Navigate to login
    navigate('/auth?reason=session-expired')

    // Show toast
    showToast('Your session expired. Please log in again.', 'info')
  }
}
```

**Estimated Effort**: 1-2 hours
**Risk**: Low (simple change)

---

## 8. Recommendation (Updated: Browser-Strict Strategy)

**Strategic Decision**: Browser version will enforce strict session validation. True offline-first capabilities deferred to React Native mobile app (see `react-native-app` feature).

**Primary Recommendation: Option B - Unified Auth Check (Browser-Simplified)**

**Rationale:**

- Fixes the root cause (split auth responsibility)
- Simplified scope: no complex offline logic needed for browser
- Can be implemented quickly
- Clean architecture for future mobile integration

**Simplified Implementation Plan (Browser-Only):**

1. Create `useAuthCheck()` hook that checks session validity (1-2 hours)
2. Update ProtectedRoute to use hook + show loading state (30 min)
3. On invalid/expired session → clear localStorage → redirect to /auth (30 min)
4. Remove or simplify SessionExpiredModal (redirect instead of modal) (30 min)
5. Test browser scenarios (1-2 hours)
6. Update documentation (30 min)

**Total Estimated Time**: 4-6 hours

**What We're NOT Doing (Deferred to Mobile):**

- ❌ Complex offline session validation
- ❌ 30-day offline access window
- ❌ Background session refresh
- ❌ Offline-first architecture

**Short Grace Period for Browser:**

- Allow 1-2 hour "airplane mode" grace (check `rock_on_session.expiresAt`)
- If session expired, redirect immediately (no working offline with expired session)
- This handles brief connectivity loss during a gig, but not true offline-first

---

## 9. Next Steps

**Immediate (This Feature):**

1. ✅ Research complete
2. Proceed to planning phase
3. Implement Option B (browser-simplified)
4. Write E2E tests for auth redirect scenarios

**Future (Separate Feature: react-native-app):**

1. True offline-first architecture
2. Secure token storage (Keychain/Keystore)
3. Biometric re-authentication
4. Background session refresh
5. 30-day offline access window

---

## Appendix A: Files Analyzed

### Core Authentication Files

- `/workspaces/rock-on/src/components/ProtectedRoute.tsx` - Route guard
- `/workspaces/rock-on/src/contexts/AuthContext.tsx` - Auth state management
- `/workspaces/rock-on/src/services/auth/SessionManager.ts` - Session persistence
- `/workspaces/rock-on/src/services/auth/SupabaseAuthService.ts` - Supabase integration
- `/workspaces/rock-on/src/services/auth/types.ts` - Auth type definitions

### UI Components

- `/workspaces/rock-on/src/components/auth/SessionExpiredModal.tsx` - Session expiry modal
- `/workspaces/rock-on/src/components/layout/Sidebar.tsx` - Displays user email
- `/workspaces/rock-on/src/components/layout/ModernLayout.tsx` - Layout wrapper

### Page Components

- `/workspaces/rock-on/src/pages/SongsPage.tsx` - Shows "Not logged in"
- `/workspaces/rock-on/src/pages/SetlistsPage.tsx` - Shows "Not logged in"
- `/workspaces/rock-on/src/pages/ShowsPage.tsx` - Shows "Not logged in"
- `/workspaces/rock-on/src/pages/PracticesPage.tsx` - Shows "Not logged in"
- `/workspaces/rock-on/src/pages/BandMembersPage.tsx` - Shows "Not logged in"

### Routing

- `/workspaces/rock-on/src/App.tsx` - Route configuration

### Evidence

- `/workspaces/rock-on/.claude/artifacts/not-logged-in.png` - Screenshot of issue

---

## Appendix B: Key Code Snippets

### ProtectedRoute Check (Current)

```typescript
// src/components/ProtectedRoute.tsx:22-31
useEffect(() => {
  const checkAuth = () => {
    const currentUserId = localStorage.getItem('currentUserId')
    const currentBandId = localStorage.getItem('currentBandId')

    // User must have both userId and bandId to access protected routes
    setIsAuthorized(!!(currentUserId && currentBandId))
    setIsChecking(false)
  }
  checkAuth()
}, [])
```

### Session Expiry Check (Current)

```typescript
// src/contexts/AuthContext.tsx:110-122
const checkSession = () => {
  const currentSession = SessionManager.loadSession()
  if (!currentSession || !SessionManager.isSessionValid(currentSession)) {
    console.warn('⚠️ Session expired - user needs to re-authenticate')
    setSessionExpired(true)
    setSession(null)
    setUser(null)
    // Clear interval since session is expired
    if (sessionCheckIntervalRef.current) {
      clearInterval(sessionCheckIntervalRef.current)
      sessionCheckIntervalRef.current = null
    }
  }
}
```

### Page Component Display (Current)

```typescript
// src/pages/SongsPage.tsx:1128-1129
<ModernLayout
  bandName={currentBand?.name || 'No Band Selected'}
  userEmail={currentUser?.email || 'Not logged in'}
  onSignOut={handleSignOut}
>
```

---

**End of Research Document**
