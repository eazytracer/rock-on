---
feature: Custom Tuning Support
created: 2025-12-11T14:17:00Z
status: research-complete
---

# Research: Custom Tuning Support

## Feature Request Summary

Design a flexible custom tuning system that supports:

1. **Variable string counts** - 6-string, 7-string, 8-string guitars, etc.
2. **Bass guitars** - 4-string, 5-string, 6-string bass with appropriate tunings
3. **Custom tunings** - Allow users to define any tuning pattern (e.g., Drop D, Open G, DADGAD)
4. **Per-member tunings** - Future capability for band members to store their own tuning preferences based on instrument

## Codebase Analysis

### Related Components

**Song Model:**

- `src/models/Song.ts:12` - Song interface with `guitarTuning?: string` field
- Current implementation: Simple optional string field
- No validation or structure
- No association with instrument type

**Database Schema:**

- `supabase/migrations/20251106000000_baseline_schema.sql:162` - `guitar_tuning TEXT DEFAULT 'Standard'` column in songs table
- Plain TEXT field with default value
- No JSONB structure currently
- Column name suggests guitar-only focus

**UI Components:**

- `src/pages/SongsPage.tsx:1620-2100` - **AddEditSongModal** (inline component)
  - **THIS IS THE ACTIVE COMPONENT** used for creating/editing songs
  - Tuning dropdown defined inline at lines 2056-2065
  - Hardcoded options: Standard, Drop D, Drop C#, Drop C, Drop B, Half-step down, etc.
  - Future: Should be database-populated list

- `src/components/songs/AddSongForm.tsx` - **LEGACY/UNUSED** (can be deleted)
- `src/components/songs/NewSongModal.tsx` - **LEGACY/UNUSED** (can be deleted)

**Repository Layer:**

- `src/services/data/RemoteRepository.ts:138` - Maps `guitarTuning` to `guitar_tuning`
- `src/services/data/RemoteRepository.ts:164` - Maps back with default 'Standard'
- Simple 1:1 field mapping, no transformation

**Related Models:**

- `src/models/SongCasting.ts` - Song casting model
  - Associates band members with songs
  - Fields: role assignments, member IDs
  - No instrument or tuning information currently
  - Could be extended for per-member tunings

**Band Member Schema:**

- `supabase/migrations/20251106000000_baseline_schema.sql` - band_memberships table
  - Fields: `id`, `user_id`, `band_id`, `role`, `permissions`, `joined_date`, `status`
  - No instrument field currently
  - No tuning preferences

### Affected Files

**Modify:**

- `supabase/migrations/20251106000000_baseline_schema.sql:162` - Update songs table schema
  - Change `guitar_tuning TEXT` to support structured tuning data
  - Consider JSONB or enhanced TEXT format

- `src/models/Song.ts:12` - Update Song interface
  - Replace `guitarTuning?: string` with structured tuning type
  - Add support for multiple instruments

- `src/pages/SongsPage.tsx:2046-2066` - Update tuning dropdown in AddEditSongModal
  - Replace hardcoded options with database-populated list
  - Add instrument selector
  - Add custom tuning entry option
  - Validate tuning format

**Delete (Legacy/Unused):**

- `src/components/songs/AddSongForm.tsx` - Legacy component, not imported anywhere
- `src/components/songs/NewSongModal.tsx` - Legacy component, not imported anywhere

- `src/services/data/RemoteRepository.ts:138,164` - Update mapping functions
  - Handle new tuning structure
  - Convert between IndexedDB and Supabase formats

**Create:**

- `src/types/tuning.types.ts` - New type definitions
  - Tuning interface
  - Instrument types enum
  - Standard tuning presets

- `src/utils/tuning.ts` - Tuning utility functions
  - Validation functions
  - Format/parse functions
  - Standard tuning definitions

- `src/components/songs/TuningSelector.tsx` - Reusable tuning input component
  - Instrument picker
  - Preset selector
  - Custom tuning editor

- `tests/unit/utils/tuning.test.ts` - Unit tests for tuning utilities
- `tests/unit/components/TuningSelector.test.ts` - Component tests

**Future (Per-Member Tunings):**

- Migration for `instrument` field in band_memberships
- Migration for member_tuning_preferences table
- Updates to SongCasting model for tuning overrides

### Dependencies

- **React Hook Form** - Already used in forms
- **Zod** - For tuning validation schema (already in project)
- **TailwindCSS** - For styling new components
- **No new external dependencies required**

## Technical Context

### Existing Patterns

**Similar Features:**

1. **Difficulty Levels** (`src/models/Song.ts:11`)
   - Stored as: `difficulty: 1 | 2 | 3 | 4 | 5`
   - Numeric with type constraint
   - Good pattern for constrained values

2. **Key Signature** (`src/models/Song.ts:9`)
   - Stored as: `key: string`
   - Free-form string
   - Could benefit from similar enhancement

3. **Setlist Items JSONB** (`supabase/migrations/20251106000000_baseline_schema.sql:224`)
   - Uses JSONB for flexible structure
   - Pattern: `items JSONB DEFAULT '[]'::jsonb`
   - Allows complex nested data
   - Good precedent for structured tuning data

**Design Patterns:**

1. **Repository Pattern** - Used throughout for data access
   - LocalRepository for IndexedDB
   - RemoteRepository for Supabase
   - Field name mapping (camelCase <-> snake_case)

2. **Type-Safe Models** - All models have TypeScript interfaces
   - Strong typing for data structures
   - Validation at compile time

3. **Optional Fields** - Many song fields are optional
   - Flexibility for incomplete data
   - Tuning should follow this pattern

### Database Schema

**Current Schema:**

```sql
CREATE TABLE songs (
  -- ... other fields ...
  guitar_tuning TEXT DEFAULT 'Standard',
  -- ... other fields ...
);
```

**Design Options:**

**Option 1: Enhanced TEXT Field (Simple)**

```sql
guitar_tuning TEXT  -- Format: "INSTRUMENT:NOTE1-NOTE2-NOTE3..."
-- Examples:
-- "GUITAR_6:E-A-D-G-B-E"
-- "BASS_4:E-A-D-G"
-- "GUITAR_7:B-E-A-D-G-B-E"
```

**Option 2: JSONB Structure (Flexible) - RECOMMENDED**

```sql
tuning JSONB  -- Structured data
-- Example:
-- {
--   "instrument": "guitar",
--   "stringCount": 6,
--   "notes": ["E", "A", "D", "G", "B", "E"],
--   "name": "Standard"
-- }
```

**Option 3: Dedicated Tuning Table (Normalized)**

```sql
CREATE TABLE tunings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  band_id UUID REFERENCES bands(id),
  name TEXT NOT NULL,
  instrument_type TEXT NOT NULL,
  string_count INTEGER NOT NULL,
  notes TEXT[] NOT NULL,
  is_preset BOOLEAN DEFAULT false,
  created_date TIMESTAMPTZ DEFAULT now()
);

-- songs table reference
ALTER TABLE songs ADD COLUMN tuning_id UUID REFERENCES tunings(id);
```

### Testing Requirements

**Unit Tests:**

1. **Tuning Utilities** (`tests/unit/utils/tuning.test.ts`)
   - Validate tuning format
   - Parse tuning strings
   - Convert between formats
   - Test standard tuning definitions

2. **TuningSelector Component** (`tests/unit/components/TuningSelector.test.ts`)
   - Instrument selection
   - Preset selection
   - Custom tuning entry
   - Validation feedback

**Integration Tests:**

1. **Song Creation with Tuning** (`tests/integration/song-tuning.test.ts`)
   - Create song with standard tuning
   - Create song with custom tuning
   - Save and retrieve tuning
   - Verify field mappings

**E2E Tests:**

1. **Song Creation Flow** (`tests/e2e/song-tuning.spec.ts`)
   - User selects instrument
   - User selects preset tuning
   - User enters custom tuning
   - Tuning displays correctly in song detail

## Risk Analysis

### High Risk

**Database Schema Migration**

- **Impact:** Changing column name/type affects all existing songs
- **Mitigation:**
  - Use additive approach: Add new column, migrate data, drop old column
  - Test migration thoroughly locally
  - Create rollback script
  - During pre-1.0: Modify baseline migration directly

**Field Mapping Complexity**

- **Impact:** Incorrect mapping between IndexedDB and Supabase breaks sync
- **Mitigation:**
  - Comprehensive unit tests for mapping functions
  - Test with various tuning formats
  - Document field mapping clearly

### Medium Risk

**UI/UX Complexity**

- **Impact:** Poor UX could make tuning feature confusing
- **Mitigation:**
  - Start with simple preset selection
  - Add custom entry as enhancement
  - User testing with musicians

**Data Validation**

- **Impact:** Invalid tuning data could break displays or sync
- **Mitigation:**
  - Strong TypeScript types
  - Zod validation schema
  - Server-side validation if needed

**Backward Compatibility**

- **Impact:** Existing songs with free-form tuning text
- **Mitigation:**
  - Migration script to parse existing tunings
  - Fallback to "custom" for unparseable data

### Low Risk

**Standard Tuning Definitions**

- **Impact:** Missing a common tuning
- **Mitigation:** Start with most common tunings, add more as needed

**Performance**

- **Impact:** JSONB queries might be slower than TEXT
- **Mitigation:** Tuning lookups are not performance-critical

## Design Considerations

### Data Structure Options

**Recommendation: JSONB with Hybrid Approach**

Use JSONB in Supabase for flexibility, but maintain backward compatibility:

```typescript
// TypeScript interface
interface Tuning {
  instrument: InstrumentType // 'guitar' | 'bass' | 'other'
  stringCount: number // 4, 5, 6, 7, 8, etc.
  notes: string[] // ['E', 'A', 'D', 'G', 'B', 'E']
  name?: string // 'Standard', 'Drop D', 'DADGAD', etc.
}

type InstrumentType = 'guitar' | 'bass' | 'other'

// Song model
interface Song {
  // ... existing fields ...
  tuning?: Tuning // Replaces guitarTuning
}
```

**Supabase Schema:**

```sql
-- Phase 1: Add new column alongside old one
ALTER TABLE songs ADD COLUMN tuning JSONB;

-- Migrate existing data
UPDATE songs
SET tuning = jsonb_build_object(
  'instrument', 'guitar',
  'stringCount', 6,
  'notes', string_to_array(guitar_tuning, ' '),
  'name', guitar_tuning
)
WHERE guitar_tuning IS NOT NULL;

-- Phase 2: Drop old column after migration validated
ALTER TABLE songs DROP COLUMN guitar_tuning;
```

### UI/UX Approach

**Phase 1 MVP: Enhanced Input**

1. **Instrument Selector** (dropdown)
   - Guitar (6-string) - default
   - Guitar (7-string)
   - Guitar (8-string)
   - Bass (4-string)
   - Bass (5-string)
   - Bass (6-string)
   - Other/Custom

2. **Tuning Preset Selector** (dropdown, dynamic based on instrument)
   - Standard presets for each instrument
   - "Custom" option

3. **Custom Tuning Entry** (shown when "Custom" selected)
   - Input field per string
   - Validation: Must be valid note (A-G with optional sharps/flats)
   - Clear labels (String 1, String 2, etc.)

**Phase 2 Enhancement: Visual Editor**

- Fretboard visualization
- Click to select notes
- Hear tuning (if Web Audio API used)

### Standard Tunings Database

**Initial Standard Tunings:**

```typescript
const STANDARD_TUNINGS: Record<string, Tuning[]> = {
  'guitar-6': [
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['E', 'A', 'D', 'G', 'B', 'E'],
      name: 'Standard',
    },
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['D', 'A', 'D', 'G', 'B', 'E'],
      name: 'Drop D',
    },
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['C#', 'G#', 'C#', 'F#', 'A#', 'D#'],
      name: 'Drop C#',
    },
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['D', 'A', 'D', 'G', 'A', 'D'],
      name: 'DADGAD',
    },
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['D', 'G', 'D', 'G', 'B', 'D'],
      name: 'Open G',
    },
    {
      instrument: 'guitar',
      stringCount: 6,
      notes: ['E', 'A', 'E', 'A', 'C#', 'E'],
      name: 'Open A',
    },
  ],
  'guitar-7': [
    {
      instrument: 'guitar',
      stringCount: 7,
      notes: ['B', 'E', 'A', 'D', 'G', 'B', 'E'],
      name: 'Standard',
    },
    {
      instrument: 'guitar',
      stringCount: 7,
      notes: ['A', 'E', 'A', 'D', 'G', 'B', 'E'],
      name: 'Drop A',
    },
  ],
  'bass-4': [
    {
      instrument: 'bass',
      stringCount: 4,
      notes: ['E', 'A', 'D', 'G'],
      name: 'Standard',
    },
    {
      instrument: 'bass',
      stringCount: 4,
      notes: ['D', 'A', 'D', 'G'],
      name: 'Drop D',
    },
  ],
  'bass-5': [
    {
      instrument: 'bass',
      stringCount: 5,
      notes: ['B', 'E', 'A', 'D', 'G'],
      name: 'Standard',
    },
  ],
}
```

## Open Questions

### For User Clarification

1. **Instrument Scope**
   - Should we support instruments beyond guitar and bass? (mandolin, ukulele, etc.)
   - Should we have a catch-all "other" instrument type?

2. **Tuning Notation**
   - Should we support scientific pitch notation (E2, A2, D3)?
   - Or just note names (E, A, D)?
   - Should we support sharps/flats (#/b)?

3. **Per-Member Tunings Priority**
   - Should we design for per-member tunings now, or wait until Phase 2?
   - How important is this feature vs. other priorities?

4. **Migration Strategy**
   - How many existing songs have tuning data?
   - Are there any common tuning patterns in existing data?

### For Implementation Approach

1. **JSONB vs TEXT**
   - JSONB is more flexible but adds query complexity
   - TEXT with structured format is simpler but less flexible
   - Recommendation: JSONB for future extensibility

2. **Preset Storage**
   - Should presets be hardcoded in UI or stored in database?
   - Recommendation: Hardcoded for MVP, database for customization later

3. **Validation Level**
   - Client-side only or server-side too?
   - Recommendation: Both (client for UX, server for security)

## Recommended Approach

### Technical Strategy

**Phase 1: Enhanced Tuning System (Current Feature)**

1. **Database Schema (Pre-1.0 - Modify Baseline)**
   - Add `tuning JSONB` column to songs table
   - Migrate existing `guitar_tuning` data to new format
   - Drop old column after validation

2. **Type System**
   - Create `tuning.types.ts` with Tuning interface
   - Update Song model to use Tuning type
   - Add Zod validation schema

3. **UI Components**
   - Create TuningSelector component
   - Integrate into SongForm
   - Update SongDetail to display structured tuning

4. **Repository Layer**
   - Update RemoteRepository mapping functions
   - Handle JSONB serialization/deserialization
   - Maintain backward compatibility during migration

5. **Testing**
   - Unit tests for tuning utilities
   - Component tests for TuningSelector
   - Integration tests for full song flow
   - E2E tests for user workflows

**Phase 2: Per-Member Tunings (Future)**

1. **Database Schema**
   - Add `instrument` field to band_memberships or user_profiles
   - Create member_tuning_preferences table
   - Add tuning_override to song_castings

2. **UI Extensions**
   - Member profile instrument editor
   - Casting editor with tuning overrides
   - Band-wide tuning preferences

### Rationale

**Why JSONB:**

- Flexible structure supports future enhancements
- Easy to query and index in PostgreSQL
- Precedent exists in codebase (setlist items)
- Supports variable string counts naturally

**Why Component-Based UI:**

- Reusable across SongForm and future member profiles
- Testable in isolation
- Consistent UX
- Easy to enhance (add visual editor later)

**Why Phased Approach:**

- Phase 1 delivers immediate value
- Doesn't block on future per-member requirements
- Can validate approach with users before Phase 2
- Reduces implementation risk

**Alternatives Considered:**

1. **Keep TEXT field with structured format**
   - Less flexible for future enhancements
   - Harder to validate and query
   - Simpler migration

2. **Normalized tuning table**
   - Better for reusable presets
   - Overkill for current requirements
   - More complex queries
   - Consider for Phase 2

3. **Separate column per string**
   - Rigid schema
   - Doesn't support variable string counts
   - Migration nightmare

**Trade-offs:**

- **JSONB complexity** vs **Future flexibility** -> Choose flexibility
- **Migration effort** vs **Better UX** -> Worth the effort
- **Simple MVP** vs **Full visual editor** -> Start simple, enhance later

## Next Steps

**Ready for Planning:** Yes

**Key Considerations for Planning:**

1. **Migration Script Required**
   - Parse existing guitar_tuning TEXT data
   - Convert to JSONB format
   - Handle edge cases (malformed data)
   - Test thoroughly before applying

2. **Type Safety Critical**
   - Strong TypeScript interfaces
   - Zod validation schema
   - Runtime type checking

3. **User Testing Recommended**
   - Validate instrument/preset selections with musicians
   - Test custom tuning entry UX
   - Ensure notation is clear

4. **Documentation Needed**
   - Update unified-database-schema.md
   - Document tuning format in code comments
   - Create user guide for tuning feature

5. **Performance Monitoring**
   - Watch JSONB query performance
   - Add indexes if needed
   - Consider caching standard tunings

**Success Criteria:**

- Users can select instrument type
- Users can choose from standard tunings
- Users can enter custom tunings
- Tunings sync correctly between local and remote
- Existing songs with tuning data migrated successfully
- All tests passing (unit, integration, E2E)
